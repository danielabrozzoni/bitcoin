import os
from itertools import combinations

# This script compares data from CSV files generated by getaddr.py, calculates overlaps
# between peer address buckets, and visualizes the results in a bar chart saved in node_address_matches.png.
#
# Prerequisites:
# - Matplotlib and NumPy installed
# - CSV files generated by getaddr.py located in the specified `directory`
#
# Before running:
# Change `directory` match your data directory (see below TODO)


# TODO: change me if necessary
BASE_DIRECTORY = "/home/daniela/Developer/bitcoin/getaddr-script/data"


def retrieve_and_clean_data(directory):
    """
    Reads CSV files from the specified directory, parses peer address data,
    and organizes it into a dictionary.

    Returns:
        dict: A dictionary where keys are filenames (cleaned) and values are dictionaries
              mapping addresses to their respective timestamps and services.
              Example:
              {
                  'filename1': {
                      'addr1': ('timestamp1', 'services1'),
                      'addr2': ('timestamp2', 'services2'),
                  },
                  'filename2': { ... }
              }
    """
    buckets = {}
    for filename in os.listdir(directory):
        if not filename.endswith(".csv"):
            continue
        bucket = {}
        file_path = os.path.join(directory, filename)
        print(file_path)
        with open(file_path, "r") as file:
            for line in file:
                #print(line)
                parsed_line = line[1:-1].split(", ")[1:]
                bucket[parsed_line[0]] = (parsed_line[1], parsed_line[2])
            clean_filename = filename.split("-")[1][:-4]
            buckets[clean_filename] = bucket
    return buckets


# Compares two address buckets and calculates the number of perfect and partial matches.
def check_overlap(bucket_a, bucket_b):
    print(f"Bucket A contains {len(bucket_a)} values")
    print(f"Bucket B contains {len(bucket_b)} values")
    perfect_matches = 0
    partial_matches = 0
    for address, (timestamp, services) in bucket_a.items():
        if address in bucket_b:
            if bucket_b[address] == (timestamp, services):
                perfect_matches += 1
            else:
                partial_matches += 1
    if len(bucket_a) != 0 and len(bucket_b) != 0:
        print(f"Perfect matches: {perfect_matches} ({round(perfect_matches * 100 / len(bucket_a), 2)}% A, {round(perfect_matches * 100 / len(bucket_b), 2)}% B)")
        print(f"Partial matches: {partial_matches} ({round(partial_matches * 100 / len(bucket_a), 2)}% A, {round(partial_matches * 100 / len(bucket_b), 2)}% B)")
    else:
        print("Empty bucket")
    return (perfect_matches, partial_matches)


def plot(nodes, matches, directory):
    import matplotlib.pyplot as plt
    import numpy as np
    x = np.arange(len(nodes))  # the label locations
    width = 0.25  # the width of the bars
    multiplier = 0

    fig, ax = plt.subplots(layout='constrained')

    for attribute, measurement in matches.items():
        offset = width * multiplier
        rects = ax.bar(x + offset, measurement, width, label=attribute)
        ax.bar_label(rects, padding=3)
        multiplier += 1

    # Add some text for labels, title and custom x-axis tick labels, etc.
    ax.set_title("Comparison of Address Matches Between Nodes")
    ax.set_xlabel('Node Pairs')
    ax.set_ylabel('Number of Address Matches')
    ax.set_xticks(x + width, nodes)
    ax.set_xticklabels(nodes, rotation=45, ha='right')
    ax.legend(loc='upper left', ncols=3)

    plt.savefig(os.path.join(directory, "node_address_matches.png"))


if __name__ == "__main__":
    dir = input('Enter the subdirectory name (within BASE_DIRECTORY) where the data is stored: ')
    directory = os.path.join(BASE_DIRECTORY, dir)
    print(f'Looking for data in {directory}...')
    buckets = retrieve_and_clean_data(directory)
    nodes = []
    matches = {
        'perfect_match': [],
        'partial_match': [],
    }
    for pair in combinations(buckets, 2):
        print(f"Comparing {pair[0]} and {pair[1]}")

        # Shortens a node name for display in plots.
        def node_label(name):
            if len(name) < 15:
                return name
            return f"{name[:5]}..{name[-5:]}"

        nodes.append(f"{node_label(pair[0])} - {node_label(pair[1])}")
        result = check_overlap(buckets[pair[0]], buckets[pair[1]])
        matches['perfect_match'].append(result[0])
        matches['partial_match'].append(result[1])
    plot(nodes, matches, directory)
